import requests
import json
import cv2
import os

# Self-created libraries
try:
    from .general_function import choice  # Relative import for package
except ImportError:
    import sys
    from os.path import dirname, abspath
    sys.path.append(dirname(abspath(__file__)))
    from general_function import choice  # Absolute import fallback

#Being imported to be used in front end as well (start)========================================================================================================================================================

def query_nvd(services, api_key = ""):

      vulns = []
      # This url is the base url for the NVD API's VE endpoint
      nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

      headers = {
            "Accept": "application/json", # Expects a JSON response
            "Connection": "close" # Close the connection after a complete request, to avoid disruption in the next request
      }

      #ask for NVD API key
      '''
       # for front end not need this, enable this if need to test
      print("\nIf you have a NVD API key, please input here")
      api_key = input("(Note: If you dont have any NVD API key, just leave this blank and click Enter to the next) ")
      '''
      if api_key != "":
            headers["apiKey"] = api_key
      
      for service in services: #services is a list of dictionary contains various service and version
            service_name = service['service']
            version = service['version']
           
            # A dictionary to contain parameter for the request
            params = {
                  "keywordSearch": f"{service_name} {version}",
                  "resultsPerPage": "20" # Limits the number of results returned to 20, coz without API key, it will limit the request per time
            }

            print(f"\n\nQuerying NVD API for {service_name} {version}...\n")

            response = requests.get(nvd_api_url, headers=headers, params=params)

            if response.status_code == 200: # If the request is successful, indicated by the code '200'
                  cve_data = response.json() # Parse the JSON response into a dictionary
                  vulnerabilities = cve_data.get("vulnerabilities", []) # The main dictionary store many sub dictionary
                  if vulnerabilities: # If the vulnerability has been found
                        for vuln in vulnerabilities:
                              cve = vuln.get("cve", {})
                              cve_id = cve.get("id", "Unknown")
                              descriptions = cve.get("descriptions", [])

                              if descriptions:
                                    description = descriptions[0].get("value", "No description")
                              else:
                                    description = "No description"
                        
                              print(f"CVE: {cve_id}\nDescription: {description}\n{'-'*60}")
                              temp_vuln = [cve_id,description]
                              vulns.append(temp_vuln)
                  else: # If no vulnerabilites are found
                        print("No matching vulnerabilities found for these keywords.")
            else: # If the request is fail (not returning code '200')
                  print("Error querying NVD API, status code:", response.status_code)
                  print("Please check your internet connection and the NVD API key")
      return vulns

#modified version for front end
def brute_force_login_front(ip_add,port):
      current_directory = os.getcwd()
      credentials_json = open(os.path.join(current_directory, "BackEnd", "login_data", "credentials.json"),"r")
      credentials = json.load(credentials_json) #convert the information from the json file into dictionary format
      vulns = []
      rstp_list = []
      output = []

      rstp_path = open(os.path.join(current_directory, "BackEnd", "login_data", "RTSP.txt"),"r")
      for path in rstp_path:
            rstp_list.append(path[0:-1])

      for user in credentials['usernames']: 
            for passw in credentials['passwords']:
                  for path in rstp_list:
                        if user == "" and passw == "":
                              rtsp_url = f"rtsp://{ip_add}:{port}/{path}"
                              temp_vuln = [["Open RTSP Stream Without Authentication","The Real-Time Streaming Protocol (RTSP) is publicly accessible without login credentials."]]
                        else:
                              rtsp_url = f"rtsp://{user}:{passw}@{ip_add}:{port}/{path}"
                              temp_vuln = [["Default Credentials Used","The camera is using factory default username/password"],["Brute Force Attack on Login Credentials", "No protection against repeated login attempts."]]

                        output.append(f"Testing URL: {rtsp_url}")
                        stream = cv2.VideoCapture(rtsp_url) #a special object defined in the cv library

                        #for screenshot
                        screenshot_path = os.path.join(os.getcwd(),"Screenshots")  #create a new directory name to store the screenshot, the format is: current directory + "Screenshots"
                        os.makedirs(screenshot_path, exist_ok=True) #the exist_ok is to prevent error if the directory already exist
                        screenshot = 0

                        if stream.isOpened() == True:
                              vulns = vulns + temp_vuln
                              streaming = True
                              while streaming:
                                    reading, frame = stream.read() #the .read() function from cv2 return two values, first is the boolean and the second is the actual frame image from the camera
                                    if not reading or frame is None:
                                          output.append("Error: Unable to read frame from RTSP stream.")
                                          break

                                    cv2.imshow("Streaming", frame) #Create a new window to view the streaming IP cam
                                    key_entered = cv2.waitKey(1) #capture the user keystroke
                                    if key_entered == ord("q"): #if user enter 'q', then quit the viewing window
                                          streaming = False
                                          break
                                    elif key_entered == ord("s"): #if the user enter 's', take a screenshot at the current moment of the streaming IP cam
                                          filename = os.path.join(screenshot_path, f"Screenshot_{screenshot}.png")
                                          cv2.imwrite(filename, frame)
                                          output.append(f"Screenshot has beesn successfully taken and stored as {filename}")
                                          screenshot += 1

                              stream.release() #Release any capture RTSP stream
                              cv2.destroyAllWindows() #Close all cv2 windows

                              credentials_json.close() #close the opened file
                              rstp_path.close()

                              if reading or frame is not None:
                                    vulns.append(["Weak or No Encryption for Video Streams", "The video feed is transmitted without encryption, allowing attackers to intercept footage."])

                              output.append(f"Successfully brute forcing into the IP Camera {ip_add} with username: '{user}', password: '{passw}' and RTSP path: '{path}'\nThe RTSP URL being used to sucessfully login your IP Camera is '{rtsp_url}'")
                              return vulns, output
      credentials_json.close()
      rstp_path.close()
      output.append("Failed to login into your IP Camera by brute force attack using the credentials in our database")
      
      return vulns, output

#Being imported to be used in front end as well (end)========================================================================================================================================================


#for use only in running the application in command line based (start)----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def select_camera(camera_dict):
      camera_num = 1
      camera_list = []
      for ip in camera_dict.keys():
            print(str(camera_num) + ") " + ip)
            camera_list.append(ip)
            camera_num += 1
      print("Please select the IP camera that wish to be assessed (based on their IP address)")
      print("Enter your choice based on the number on the left of the IP address")
      chosen = choice(2)
      chosen_IP = camera_list[int(chosen) - 1]
      print(f"\nYour chosen IP Camera is {chosen_IP}")
      return chosen_IP

def get_camera_detail(ip, camera_dict):
      services_list = camera_dict[ip]
      vendor = ""
      firmware_version = ""
      get_detail = True
      while get_detail:
            for definition, data in services_list.items():
                  if definition == 'services':
                    for service in data:
                        print(f"Port: {service['port']}")
                        print(f"Service: {service['service']}")
                        print(f"Version: {service['version']}")
                        print("\n")
            print(f"Vendor: {vendor}")
            print(f"Firmwar Version: {firmware_version}")
            print("Since this tool cannot detect your IP camera's vendor and firmware version")
            answer = input("Are you wish to add/modify? [Yes/No] ")
            if answer.lower() == "yes":
                  vendor = input("Please type the vendor's name: ")
                  firmware_version = input("Please type the firmware version: ")
            else:
                  get_detail = False
                  break
      service_version = []
      for definition, data in services_list.items():
            if definition == 'services':
                for service in data:
                        service_version.append({'service': service['service'], 'version': service['version']})
      
      if vendor != "" or firmware_version != "":
            service_version.append({'service': vendor, 'version': firmware_version})

      if vendor == "":
            vendor = "Unknown"
      if firmware_version == "":
            firmware_version = "Unknown"

      camera_dict[ip]["detail"] = {"vendor": vendor, "firmware version": firmware_version}

      return service_version, camera_dict

def brute_force_login(ip_add,port):
      current_directory = os.getcwd()
      credentials_json = open(os.path.join(current_directory, "login_data", "credentials.json"),"r")
      credentials = json.load(credentials_json) #convert the information from the json file into dictionary format
      vulns = []

      rstp_list = []
      rstp_path = open(os.path.join(current_directory, "login_data","RTSP.txt"),"r")
      for path in rstp_path:
            rstp_list.append(path[0:-1])

      for user in credentials['usernames']: 
            for passw in credentials['passwords']:
                  for path in rstp_list:
                        if user == "" and passw == "":
                              rtsp_url = f"rtsp://{ip_add}:{port}/{path}"
                              temp_vuln = [["Open RTSP Stream Without Authentication","The Real-Time Streaming Protocol (RTSP) is publicly accessible without login credentials."]]
                        else:
                              rtsp_url = f"rtsp://{user}:{passw}@{ip_add}:{port}/{path}"
                              temp_vuln = [["Default Credentials Used","The camera is using factory default username/password"],["Brute Force Attack on Login Credentials", "No protection against repeated login attempts."]]

                        print(f"Testing URL: {rtsp_url}")
                        stream = cv2.VideoCapture(rtsp_url) #a special object defined in the cv library

                        #for screenshot
                        screenshot_path = os.path.join(os.getcwd(),"Screenshots")  #create a new directory name to store the screenshot, 
                                                                                    #the format is: current directory + "Screenshots"
                        os.makedirs(screenshot_path, exist_ok=True) #the exist_ok is to prevent error if the directory already exist
                        screenshot = 0

                        if stream.isOpened() == True:
                              vulns = vulns + temp_vuln
                              streaming = True
                              while streaming:
                                    reading, frame = stream.read() #the .read() function from cv2 return two values, 
                                                                  #first is the boolean and the second is the actual 
                                                                  # frame image from the camera
                                    if not reading or frame is None:
                                          print("Error: Unable to read frame from RTSP stream.")
                                          break

                                    cv2.imshow("Streaming", frame) #Create a new window to view the streaming IP cam
                                    key_entered = cv2.waitKey(1) #capture the user keystroke
                                    if key_entered == ord("q"): #if user enter 'q', then quit the viewing window
                                          streaming = False
                                          break
                                    elif key_entered == ord("s"): #if the user enter 's', take a screenshot at the current moment of the streaming IP cam
                                          filename = os.path.join(screenshot_path, f"Screenshot_{screenshot}.png")
                                          cv2.imwrite(filename, frame)
                                          print(f"Screenshot has beesn successfully taken and stored as {filename}")
                                          screenshot += 1

                              stream.release() #Release any capture RTSP stream
                              cv2.destroyAllWindows() #Close all cv2 windows

                              credentials_json.close() #close the opened file
                              rstp_path.close()

                              if reading or frame is not None:
                                    vulns.append(["Weak or No Encryption for Video Streams", "The video feed is transmitted without encryption, allowing attackers to intercept footage."])

                              print(f"Successfully brute forcing into the IP Camera {ip_add} with username: '{user}', password: '{passw}' and RTSP path: '{path}'\nThe RTSP URL being used to sucessfully login your IP Camera is '{rtsp_url}'")
                              return vulns
      credentials_json.close()
      rstp_path.close()
      print("Failed to login into your IP Camera by brute force attack using the credentials in our database")
      return vulns

def proceed_with_brute_force_attack(ip, camera_dict):
      services_list = camera_dict[ip]
      port_num = []

      for definition,data in services_list.items():
            if definition == 'services':
                for service in data:
                        port_num.append(service['port'])
      print("\n\nNow, the application wish to conduct a brute force attack against your selected IP camera")
      print("However, the brute force attack may be taken hours to be completed")
      print("(As each attempt is taken 30 seconds to be completed to test the connection to your IP Camera)")
      print("And this attack will give you an overview if the credential you're using for your IP Camera is secure or insecure")
      print("\n\nIf you choose to proceed with the brute force attack, here are some insturctions:")
      print("1) Make sure your local network connection is stable")
      print("2) You can press 'q' to quit the RTSP streaming at any time")
      print("3) You can press 's' to take screenshot of your IP Camera footage\n")
      getting_response = True
      while getting_response:
            answer = input("Are you wish to proceed? [Yes/No]  ")
            if answer.lower() == "yes":
                  for port in port_num:
                        vulns = brute_force_login(ip,port)
                  getting_response = False
                  break
            else:
                  getting_response = False
                  vulns = []
                  break
      return vulns
     
      

def vuln_assessment_main(camera_dict):
      chosen_ip_cam = select_camera(camera_dict)
      service_details, camera_dict = get_camera_detail(chosen_ip_cam, camera_dict)
      vulns_list_1 = query_nvd(service_details)
      vulns_list_2 = proceed_with_brute_force_attack(chosen_ip_cam, camera_dict)
      final_vulns_list = vulns_list_1 + vulns_list_2

      camera_dict[chosen_ip_cam]['vulnerabilities'] = final_vulns_list
      
      
      return camera_dict

#for use only in running the application in command line based (end)----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
     
     testing_camera = {
     '192.168.212.37': 
       {'services': [{'port': 8554, 'service': 'rtsp', 'product': 'VLC rtspd', 'version': '1.1.9'}, {'port': 8555, 'service': 'rtsp', 'product': 'VLC rtspd', 'version': '1.1.9'}]}, 
     '192.168.161.13': 
       {'services': [{'port': 8554, 'service': 'rtsp', 'product': 'VLC rtspd', 'version': '1.1.9'}]}
    }
     
     testing_camera_2 = {}

     testing_camera = vuln_assessment_main(testing_camera)
     print(testing_camera)
