# -*- coding: utf-8 -*-
"""Copy of Testing_AI_For_DoS_IDS_(Success).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UyVGBmAHlJm59-3yEtyw3Zab_LvdMI_s

# **DoS Detection**
"""

import zipfile
import os

zip_file = "/content/sample_data/iot_intrusion_dataset.zip"
extract_files = "/content/sample_data/extracted_pcap_files"

# Extract the .zip file
with zipfile.ZipFile(zip_file, 'r') as files:
    files.extractall(extract_files)

print(f"‚úÖ Extracted .pcap files to: {extract_files}")

"""---



---

**Install necessary components**
"""

pip install scapy pandas numpy scikit-learn joblib

"""---



---

**Extract features from the .pcap files**

1Ô∏è‚É£ Destination IP (dst_ip)
Why?

Helps identify whether an IP is being specifically targeted in an attack.
SYN flood attacks usually target a single victim IP (e.g., 192.168.1.200).
Normal traffic is usually more distributed across different destination IPs.
‚úî Example:
‚úÖ Normal Traffic ‚Üí Destinations vary (192.168.1.10, 192.168.1.50, etc.)
‚ùå SYN Flood Attack ‚Üí Targeted at one IP (192.168.1.200)

2Ô∏è‚É£ Destination Port (dst_port)
Why?

Helps detect if the attack is targeting a specific service.
Many attacks target specific ports known for vulnerabilities (e.g., 554 for RTSP cameras).
Normal traffic uses a variety of ports (e.g., 80 for HTTP, 443 for HTTPS).
‚úî Example:
‚úÖ Normal Traffic ‚Üí Uses mixed ports: 80 (Web), 443 (HTTPS), 22 (SSH), 53 (DNS)
‚ùå SYN Flood Attack ‚Üí Floods one port: 554 (RTSP)

3Ô∏è‚É£ Packet Size (packet_size)
Why?

Attack traffic often has fixed-size packets, whereas normal traffic varies in size.
SYN flood packets usually have a small and constant size (~60 bytes).
Normal traffic packets vary in size depending on the protocol (HTTP, DNS, etc.).
‚úî Example:
‚úÖ Normal Traffic ‚Üí Varies (50-150 bytes, depends on data)
‚ùå SYN Flood Attack ‚Üí Fixed size (60 bytes per packet)

4Ô∏è‚É£ SYN Flag (syn_flag)
Why?

SYN flood attacks send a high number of SYN packets without completing the handshake.
Normal traffic has both SYN and ACK packets (full handshake).
‚úî Example:
‚úÖ Normal Traffic ‚Üí SYN sometimes, but also has ACK packets.
‚ùå SYN Flood Attack ‚Üí SYN always (syn_flag = 1), no ACKs.

5Ô∏è‚É£ ACK Flag (ack_flag)
Why?

Helps detect if the handshake is completed or not.
Normal traffic has ACK responses (ack_flag = 1), but SYN flood attacks do not receive ACKs (ack_flag = 0).
‚úî Example:
‚úÖ Normal Traffic ‚Üí SYN + ACK (ack_flag = 1)
‚ùå SYN Flood Attack ‚Üí Only SYN (ack_flag = 0)

---



---

**Train the model using dos .pcap files 1 and 4**
"""

from scapy.all import rdpcap, IP, TCP
import pandas as pd
import joblib
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# List of PCAP files and their respective DoS filtering rules
pcap_files = [
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-1-dec.pcap", "222.", "192.168.0.13", 554),  # First rule
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-4-dec.pcap", "111.", "192.168.0.24", 19604)  # Second rule
]

# Function to extract features from a given PCAP file
def extract_features_from_pcap(pcap_path, attack_src_prefix, attack_dst, attack_port):
    packets = rdpcap(pcap_path)
    traffic_data = []

    for packet in packets:
        if IP in packet and TCP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            dst_port = packet[TCP].dport
            packet_size = len(packet)
            syn_flag = 0
            ack_flag = 0

            # Check if the SYN flag (0x02) is set in the TCP header
            if packet[TCP].flags & 0x02:
                syn_flag = 1
            else:
                syn_flag = 0

            # Check if the ACK flag (0x10) is set in the TCP header
            if packet[TCP].flags & 0x10:
                ack_flag = 1
            else:
                ack_flag = 0

            # Labeling: DoS attack if it matches the Wireshark rule for this PCAP file
            if (dst_ip == attack_dst and syn_flag == 1 and
                src_ip.startswith(attack_src_prefix) and dst_port == attack_port):
                label = 1  # DoS Attack
            else:
                label = 0  # Normal Traffic

            traffic_data.append([dst_ip, dst_port, packet_size, syn_flag, ack_flag, label])

    return pd.DataFrame(traffic_data, columns=["dst_ip", "dst_port", "packet_size", "syn_flag", "ack_flag", "label"])

# Extract features from both PCAP files
df_list = []
for pcap_file, src_prefix, dst_ip, dst_port in pcap_files:
    df_list.append(extract_features_from_pcap(pcap_file, src_prefix, dst_ip, dst_port))

# Merge both datasets
df_combined = pd.concat(df_list, ignore_index=True)

# Convert categorical IP addresses to numerical values
df_combined["dst_ip"] = df_combined["dst_ip"].astype("category").cat.codes

# Split data into features (X) and labels (y)
X = df_combined.drop(columns=["label"])
y = df_combined["label"]

# Split into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the IDS model using a Random Forest Classifier
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Save the updated model
joblib.dump(model, "/content/sample_data/ids_model_v2.pkl")

# Evaluate model performance
y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

# Print results
print(f"‚úÖ Accuracy: {accuracy:.4f}")
print(f"üéØ Precision: {precision:.4f}")
print(f"üì¢ Recall: {recall:.4f}")
print(f"üìä F1-score: {f1:.4f}")

"""**now test the model again**

ids_model v2
"""

from scapy.all import rdpcap, IP, TCP
import pandas as pd
import joblib
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Load trained IDS model
model = joblib.load("/content/sample_data/ids_model_v2.pkl")

# List of PCAP files and their respective DoS filtering rules
pcap_files = [
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-1-dec.pcap", "222.", "192.168.0.13", 554),  # First rule
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-2-dec.pcap", "222.", "192.168.0.13", 554),
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-3-dec.pcap", "111.", "192.168.0.13", 554),
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-4-dec.pcap", "111.", "192.168.0.24", 19604),  # Second rule
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-5-dec.pcap", "111.", "192.168.0.24", 19604),
    ("/content/sample_data/extracted_pcap_files/dos-synflooding-6-dec.pcap", "111.", "192.168.0.24", 19604)
]

# Function to extract features from a given PCAP file
def extract_features_from_pcap(pcap_path, attack_src_prefix, attack_dst, attack_port):
    packets = rdpcap(pcap_path)
    traffic_data = []

    for packet in packets:
        if IP in packet and TCP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            dst_port = packet[TCP].dport
            packet_size = len(packet)
            syn_flag = 1 if packet[TCP].flags & 0x02 else 0  # SYN flag
            ack_flag = 1 if packet[TCP].flags & 0x10 else 0  # ACK flag

            # Labeling: DoS attack if it matches the Wireshark rule for this PCAP file
            if (dst_ip == attack_dst and syn_flag == 1 and
                src_ip.startswith(attack_src_prefix) and dst_port == attack_port):
                label = 1  # DoS Attack
            else:
                label = 0  # Normal Traffic

            traffic_data.append([dst_ip, dst_port, packet_size, syn_flag, ack_flag, label])

    return pd.DataFrame(traffic_data, columns=["dst_ip", "dst_port", "packet_size", "syn_flag", "ack_flag", "label"])

file = 1
for pcap_file, src_prefix, dst_ip, dst_port in pcap_files:
    # Extract features from new PCAP file
    df_test = extract_features_from_pcap(pcap_file, src_prefix, dst_ip, dst_port)

    # Convert categorical IP addresses to numerical values
    df_test["dst_ip"] = df_test["dst_ip"].astype("category").cat.codes

    # Split into features (X) and labels (y)
    X_test = df_test.drop(columns=["label"])
    y_test = df_test["label"]

    #df_test = extract_features_from_pcap(pcap_file)
    #print(df_test.head(10))  # Show first 10 packets with labels

    # Predict using the trained model
    y_pred = model.predict(X_test)


    # Evaluate model performance
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred)
    recall = recall_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)

    # Print results
    print("\n")
    print(f"Test with .pcap file number {file}")
    print(f"‚úÖ Accuracy: {accuracy:.4f}")
    print(f"üéØ Precision: {precision:.4f}")
    print(f"üì¢ Recall: {recall:.4f}")
    print(f"üìä F1-score: {f1:.4f}")
    print(pd.Series(y_pred).value_counts())  # Show count of 0s (normal) and 1s (DoS)
    file += 1

